#+AUTHOR: Tiphaine Despr√©s
#+email: tiphaine.despres@gmail.com
#+PROPERTY: BLOG Sample Stat
#+STARTUP: fninline overview

#+OPTIONS: <:nil d:nil timestamp:t
#+OPTIONS: ^:nil tags:nil
#+OPTIONS: toc:nil num:nil
#+SEQ_TODO: TODO READY DONE
* Emacs :Emacs:
** DONE Emacs + ESS = loving R :R:
   SCHEDULED: +<2016-12-30 ven.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2016-12-30-emacs-ess-loving-r
   :END:
   Since my second year of university I have studied Statistic with R on Windows using
   the basic text editor from the R GUI console. I was happy with it for a
   couple of years. However, when I start coding more complex and longer
   function, it was a nightmare to handle human issues, specially
   parentheses tracking. A professor told me that they were some programs
   specific to code in R, such as [[http://nbcgib.uesc.br/lec/software/editores/tinn-r/en][Tinn-R]] or the well known [[https://www.rstudio.com/][R-Studio]]. I
   also found that Notepad++ as a plugin ([[https://sourceforge.net/projects/npptor/][nppToR]]) to link the text
   editor to R. However, after trying R-Studio and Notepad++, I was not
   very happy with them. I always did not like the multi-windows
   design from R-Studio, and Notepad++ was only a better way to use
   the script function from the R GUI. It was not fully integrated
   R. Finally, my professor told me about Emacs, and how it was working
   with R. I first try it with Windows, using the very good
   [[http://vgoulet.act.ulaval.ca/en/emacs/][Emacs version from Vincent Goulet]]. It was exactly what I was looking for. A software
   that can interact with R without a lot of windows, and well integrated
   with R. Few years later, I jump to Linux using first Manjaro (an
   ArchLinux distribution), and after Xubuntu to keep the very good XFCE
   desktop environment.
   #+ATTR_HTML: :width 800
   [[/assets/images/screenshoot-emacs.png][file:/assets/images/screenshoot-emacs.png]]
   For the reader who don't know anything about [[https://www.gnu.org/software/emacs/][Emacs]] this is a free
   software from the GNU licence which can speak R using [[https://ess.r-project.org/][ESS]] package (for Emacs
   Speaks Statistic). But Emacs did not speak only statistic, this is an
   incredible tool that can speak multiple computers languages, read your
   email and much more. In fact, I am writing this blog article using
   Emacs through  [[http://orgmode.org/][Org-mode]]. Emacs is a cross-platform program which can
   be used with Windows or Mac Os, and also Linux.
   I will put more articles in this blog describing how I am using Emacs
   with R, and for blogging, and hopefully you will consider it to use
   for your own projects.

* R :R:
** DONE For loop                                                       :Loop:
   SCHEDULED: <2017-01-20 ven.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-01-20-for-loop
   :END:
   Using loop with R is not the proper behaviour to have. Indeed,
   using the apply functions family such as /tapply/, /lapply/, and so
   one are a better way to do it, but for me, this is in some case too
   complicated.
   The apply family functions improve the speed rate of T and the management of the memory. Thus,  apply functions is relevant to use when you have big data-set to play with.
   Instead of using apply functions, I used =for= loop. This is simpler to understand it  for me and with moderate data-set (about few thousand of rows and 100 columns) the gain of apply functions is limited.
   Like this, =for= loop can be read again quickly even when you comeback to your code years later.
   I will now provide a small example to understand when you can use =for= loop and how to used them.  Also, note that understanding =for= loop will lead to use =foreach= function which allow parallelisation computing. It will be explain in another post.
   
   So, let's begin the =for= loop example.
   I will show you how to do spaghetti plot from tree ring data. 
*** About the data 
    Every year, tree make rings. We can count them to have the tree
    age, and also measure them to know a little more about the tree
    and its story. Indeed, tree increment (ring width from a year to
    another) give information on past climate, past disturbances
    (pest, drought, fire, ice and wind storms, etc.). 

    In this data set([[/assets/data/tree rings increment.txt][tree rings increment]]) you will find tree rings
    increment [in mm] from 19
    different trees (V1 to V19). The NA value is for year without
    increment information for this tree (it was not born), and the row
    #270 is for AD 2011  and the row #1 for AD 1741.
    
    The data look like this:
   #+NAME: data_ring
   #+BEGIN_SRC R :results output :exports both :session t 
setwd("./assets/data/") # change following your own working directory
library(data.table) #load data.table at least V.1.10 (to have fread function)
increment_data <- fread("tree rings increment.txt")

##if you did not want to use data.table V1.10 (which allow the fread function use the following code
#increment_data <- read.table("tree rings increment.txt",sep=";",h=T) #for your data,
#Because trees have not the same age, there is a lot of NA value and the length of
#your data frame is equal to the year of the oldest trees (for me it was a tree not show in this sub-sample).
#print(increment_data[1:3])

increment_data[, .(V1,V2,V3)]

#+END_SRC

#+RESULTS: data_ring
#+begin_example
data.table 1.10.0
  The fastest way to learn (by data.table authors): https://www.datacamp.com/courses/data-analysis-the-data-table-way
  Documentation: ?data.table, example(data.table) and browseVignettes("data.table")
  Release notes, videos and slides: http://r-datatable.com
         V1     V2    V3
  1:     NA     NA    NA
  2:     NA     NA    NA
  3:     NA     NA    NA
  4:     NA     NA    NA
  5:     NA     NA    NA
 ---                    
266: 128.99 182.54 66.89
267: 130.45 182.80 67.14
268: 131.54 183.24 67.50
269: 132.25 183.48 67.73
270: 132.76 184.34 68.14
#+end_example

We are now going to plot each tree starting from their first year of
growth record (i.e. the closest year to the row #1), and then continue
until the year AD 2011 (i.e. row #270). 
Because in data-set there is no year with 0 of increment, we need to
add it for each trees using the following code example for one tree: 

   #+BEGIN_SRC R :results output  :exports both :session t
    # the 3 following code line are just to help to generate the graphic frame
increment_data_unique <- increment_data[,1]
increment_data_unique <- increment_data_unique[complete.cases(increment_data_unique) ]
increment_data_unique <- rbind(list(0),increment_data_unique)
# I am pretty sure that those 3 lines of code are not required.
as.data.table(increment_data_unique)
   #+END_SRC 

   #+RESULTS:
   #+begin_example
	    V1
     1:   0.00
     2:   0.71
     3:   1.64
     4:   2.07
     5:   2.46
    ---       
   137: 128.99
   138: 130.45
   139: 131.54
   140: 132.25
   141: 132.76
#+end_example
Here we can see that we remove all NA value, and put a 0.00 value for
the first year of growth of the tree



Because we need to do it for each 19 trees, this is easier to do it
within a =for= loop like this:

   #+BEGIN_SRC R :results graphics :exports code :session t :file "Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg" :width 1200 :height 1000 :units "px"
#pdf("Multiplot radial growth sugar maple between 150 and 160 years old.pdf", width=12, height=8) #to save the plot as PDF

plot(as.numeric(rownames(increment_data_unique))-1,increment_data_unique[[1]],xlab="Age [in years]",
     ylab="radial growth [in mm]",main="Radial growth of 19 trees between 150 and 160 yrs",
     type="n",ylim=c(0,250),xlim=c(0,165)) #generate just the frame of the graphic to have all the same scale

for (i in names(increment_data)) { #for loop to draw one by one, each line of tree increments, starting all in age 0
 #use of names(increment_data) to have the names of each trees from "V1" to "V19"

    increment_data_unique <-increment_data[,i,with=F]#with=FALSE to have the whole column
    increment_data_unique <- as.data.frame(increment_data_unique[complete.cases(increment_data_unique), ]) #remove all the NA value
    increment_data_unique <- rbind(0,increment_data_unique) # add the 0 mm of DBH to start all tree at 0 years-old, 0 DBH
    par(new=TRUE) #allow to combine plots
    plot(as.numeric(rownames(increment_data_unique))-1,increment_data_unique[[1]],xlab="Age [in years]",
         ylab="radial growth [in mm]",
         main="Radial growth of 19 trees between 150 and 160 yrs",type="l",ylim=c(0,250),xlim=c(0,165)) #draw the plots for a single tree.
    #then restart the loop with the next tree, etc.
}
#dev.off() # save the graphic in your directory

   #+END_SRC

   #+RESULTS:
   [[file:Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg]]


  [[/assets/data/Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg][file:/assets/data/Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg]]


If you want, I have put the all code in my GitHub with the data-set [[https://github.com/despresT/Dendro-spaghetti-plot][Dendro-spaghetti-plot]]
 




** DONE Convert factor to character
   SCHEDULED: <2017-02-12> :factor:convert:
   SCHEDULED: <2017-01-12 jeu.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-01-12-convert-factor-to-character
   :END:
   In R, you used sometimes functions to convert vectors to another
   format with =as.character=, =as.factor= or =as.numeric=.
   However, you need to be careful when using the function =as.numeric= on
   a factor. Indeed, if the factor contains factor number, it will
   convert them to the level number and not convert the writing number
   from your factor.
   Here is a short example:
   #+NAME: block1
   #+BEGIN_SRC R :results output :exports both :session t
   library(data.table)
   set.seed(23) #set.seed to have the same random value as in this example
   to_convert <- factor(runif(1:10, min = 0, max = 100))
   print(levels(to_convert))
   #+END_SRC
   #+RESULTS: block1
   : data.table 1.9.8
   :   The fastest way to learn (by data.table authors): https://www.datacamp.com/courses/data-analysis-the-data-table-way
   :   Documentation: ?data.table, example(data.table) and browseVignettes("data.table")
   :   Release notes, videos and slides: http://r-datatable.com
   :  [1] "22.3072855733335" "33.1896589370444" "42.3720560967922" "57.6603659661487"
   :  [5] "71.072455169633"  "81.9448956055567" "84.052187949419"  "96.3544549420476"
   :  [9] "97.8130409261212" "99.6611237060279"
   #+BEGIN_SRC R :session t :results table :colnames yes :exports both
   data.table(factor_to_convert = to_convert,
   using_as_numeric_only = as.numeric(to_convert),
   using_as_character_first = as.numeric(as.character(to_convert)))
   #+END_SRC
   #+RESULTS:
   | factor_to_convert | using_as_numeric_only | using_as_character_first |
   |-------------------+-----------------------+--------------------------|
   |  57.6603659661487 |                     4 |         57.6603659661487 |
   |  22.3072855733335 |                     1 |         22.3072855733335 |
   |  33.1896589370444 |                     2 |         33.1896589370444 |
   |   71.072455169633 |                     5 |          71.072455169633 |
   |  81.9448956055567 |                     6 |         81.9448956055567 |
   |  42.3720560967922 |                     3 |         42.3720560967922 |
   |  96.3544549420476 |                     8 |         96.3544549420476 |
   |  97.8130409261212 |                     9 |         97.8130409261212 |
   |   84.052187949419 |                     7 |          84.052187949419 |
   |  99.6611237060279 |                    10 |         99.6611237060279 |
   So, be careful when you are using factor with numerical levels and you
   want to convert them.


** DONE Creating a function                                        :function:
   SCHEDULED: <2017-01-22 dim.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-01-22-creating-a-function
   :END:
   In R, most of people used build-in functions which are very useful
   for all basics statistical analyses. When you need to do more complex
   statistics you can use packages.
   There is almost every current statistical functions and more in the
   [[https://cran.r-project.org/][CRAN repository]]. However, time to time you will need to build your own function. Usually, when I build a function is because =for= loop will not be efficient and that I need to put different parameters that I can change.
   I will take here an easy example that I have previously done for my work.
   I wanted to build a short function to draw maps and save them if I needed to.

#+BEGIN_SRC R  :session t :exports none

setwd("./assets/data")

#+END_SRC

#+RESULTS:
: /home/tiphaine/blog/SampleStat
*** The data
There is two tables in this example. The first one
[[/assets/data/data_plot_scale.txt][data_plot_scale.txt]] is data of forest plots location, with different
information such as the trees status, the (living or dead), mark (NA
for no marks, DBH for trees with diameter information), dead for dead
trees position only and mortality for mortality pattern), the stands names (Stand_ID.m),
lng for longitude and lat for latitude coordinates and a result like
state 1 to 3 in the column pattern_state.
The second table is very similar but at the stand scale
[[/assets/data/data_stand_scale.txt][data_stand_scale.txt]].

Those data represent results of spatial patterns (aggregation,
repulsion or random) in forest at the plot and stand scales. Because
several plots, which could have different patterns states, are in one
stands, the stands patterns could be different from the plots
scale. Also, because I needed a tree threshold to compute spatial
patterns, there is few plots and stands that cannot be analyse for the
dead status (stands #4, for example).

#+BEGIN_SRC R :results output :exports both :session t 
library(data.table)
data_plot_pat <- fread("data_plot_scale.txt") #read the data
data_stand_pat <- fread("data_stand_scale.txt")

data_plot_pat
#+END_SRC

#+RESULTS:
#+begin_example
      Status mark Stand_ID.m      lng      lat pattern_state
   1:   dead dead         17 20.11335 49.18592        state2
   2:   dead dead         17 20.11335 49.18592        state2
   3:   dead dead         17 20.11335 49.18592        state2
   4:   dead dead         17 20.11794 49.18627        state2
   5:   dead dead         17 20.11798 49.18874        state2
  ---                                                       
1544: living   NA         33       NA       NA        state2
1545: living   NA         33       NA       NA        state2
1546: living   NA         33       NA       NA        state2
1547: living   NA         33       NA       NA        state1
1548: living   NA         33       NA       NA        state1
#+end_example

When doing functions you will need first to create arguments (vector) that will
be used in the function. 
In this example, I will use status as a proxy
for Status (note the S uppercase difference), markk for selecting
mark, and then just 2 others FALSE or TRUE vector is I want to have
the graphics outputs with the stands and if I want to save same or not
in the current directory.

*** The function 
#+BEGIN_SRC R :results output :exports code :session t
map_draw_blog <- function (status, markk, with.stand, save, ...) { #usually put ... to path others arguments
    library(ggmap)#use library instead of require to stop the function if you did not have the library
    library(ggplot2)
    library(data.table)
     #plot prep data
    setkey(data_plot_pat, Status, mark)
    #below you need to put %in% for the mark to take into account the mark == NA
    for_mapping_plot  <- data_plot_pat[Status == status & mark %in% markk] [, .( Stand_ID.m,lng, lat, pattern_state)] 

    #remove duplicated rows
    for_mapping_plot <- for_mapping_plot [!duplicated(for_mapping_plot )]

     #Stand prep data
    small_data_inf <- data_plot_pat[, .( Stand_ID.m, lng, lat)]

    #compute the mean of lng and lat by Stand_ID.m with removing NA value  only to remove lat and lng NA value
    to_map <-small_data_inf[, lapply(.SD, mean, na.rm = T), by = Stand_ID.m]

    pattern_to_put_map <- data_stand_pat[Status == status & mark %in% markk] [, .(Stand_ID.m, pattern_state)]

    for_mapping <- merge(to_map, pattern_to_put_map, by = "Stand_ID.m", all = T)#all = TRUE to keep all the no match from the 2 tables
    #keep only data with complete cases (remove row with NA values)
    for_mapping <- for_mapping[complete.cases(for_mapping)]
    
    #create the map background using Google satellite data
    google_map <- get_map(location = c(14,46,26,49),  maptype = "satellite", source = "google", zoom = 6)
    if(with.stand == TRUE) {
        if(save == TRUE) {
            ggmap(google_map) +  geom_point(data = for_mapping, aes(
        lng,  lat, color = factor(pattern_state)), 
	size = 10, alpha =.80)+  geom_point(data = for_mapping_plot,
        aes( lng,  lat, color = factor(pattern_state)), size = 2)+  
	geom_label(data = for_mapping, aes(lng,  lat + .2, label =
        Stand_ID.m,color = factor(pattern_state)), size = 4) + 
	ggsave(paste0(status, " ", markk, " map with stand and plots patterns.jpg"))
        } else { #end if save = TRUE
            ggmap(google_map) +  geom_point(data = for_mapping, aes(
        lng,  lat, color = factor(pattern_state)), 
	size = 10, alpha =.80)+  geom_point(data = for_mapping_plot,
        aes( lng,  lat, color = factor(pattern_state)), size = 2) +  
	geom_label(data = for_mapping, aes(lng,  lat + .2, label = Stand_ID.m,color = factor(pattern_state)), size = 4)
        }
    } else { #end if with.stand = TRUE
        if(save == TRUE) {
            ggmap(google_map) +  geom_point(data = for_mapping_plot,
        aes( lng,  lat, color = factor(pattern_state)), size = 2)+  
	geom_label(data = for_mapping_plot, aes(lng,  lat + .2, label
        = Stand_ID.m,color = factor(pattern_state)), size = 4) + 
	ggsave(paste0(status, " ", markk, " map without stand and plots patterns.jpg"))
        } else {
            ggmap(google_map) + geom_point(data = for_mapping_plot, aes( lng,  lat, color = factor(pattern_state)), size = 2)
        }
    }
}
#+END_SRC

#+RESULTS:

Here you can use the freshly build function =map_draw= that we just
created. The status can be ="living"= or ="dead"=. 
For the =markk= note that you need to put =NA= without any quote. Also,
you can put just F for FALSE or write FALSE, and the same for TRUE,
the result will be the same.

 #+BEGIN_SRC R :session t :exports code :results output graphics :width 1200 :height 1000 :units "px" :file "./assets/data/plot_stand.jpg"
map_draw_blog(status = "living", markk = NA, with.stand = T, save = F)
map_draw_blog(status = "living", markk = "DBH", with.stand = FALSE, save = T)
map_draw_blog(status = "dead", markk = "dead", with.stand = T, save = TRUE)
map_draw_blog(status = "dead", markk = "mortality", with.stand = T, save = T)
#+END_SRC


[[/assets/data/fourplots.png][file:/assets/data/fourplots.png]]

I edit the graph using [[https://inkscape.org/en/][Inkscape]] to put a red arrow on the plots/stands
that appear only for living status.



** TODO Nested =for= loop                                                :loop:
I already talk about single =for= loop

** TODO data.table :data.table:
When you are doing a lot of R, you can find two different kind of
people, the [[https://cran.r-project.org/web/packages/dplyr/index.html][dplyr]] and the [[https://github.com/Rdatatable/data.table/wiki][data.table]] people. Indeed, those to packages
are used for table manipulation. They are like the [[http://ggplot2.org/][ggplot2]] function
 for graphic, when you know them  they change
your R experience and you cannot go back. 

*** dplyr
I will not talk a lot about =dplyr= package, because I am not using
it. However, you need to know few things about it. Usually, =dplyr= is
used with another package named [[https://github.com/tidyverse/tidyr][tidyr]], and since recently, you
can find one package which will load both of them and more (load also
=ggplot2=, =readr=, etc.) and named [[https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/][tidyverse]].

To be simple, =dplyr= is very useful to handle object, and specially for
sorting, sub-sample, etc. thanks to the new operator =%>%=.
This operator will pipe object to another line to make more change on
it. It is very convenient to avoid typing multiple times the object
names like this:

#+BEGIN_SRC R :results outputs  :exports both
set.seed(121)
data <- rnorm(10)
data <- data + 44

# With dplyr package
library(dplyr)
set.seed(121)
data2 <- rnorm(10) %>%
    + 44

identical(data,data2)

#+END_SRC

#+RESULTS:
: TRUE

But, there is a lot of very nice function with =dplyr= to select,
sub.select, sort, replace data from tables.

If you are using emacs, you can define a key-bind for =%>%=. Here is the
lisp code you will need to put in your .emacs config file. 
#+BEGIN_SRC emacs-lisp
;;Define shortcut key for %>% function
(global-set-key (kbd "<M-f5>") 'dplyr-function)
(defun dplyr-function ()
  (interactive)
  (insert " %>%"))
#+END_SRC
Thus, in my example, the shortcut will be Meta (Alt) - f5. Of 
course, you can change it for whatever you like, just be sure that
your shortcut is not already use.

You will find a lot of site to learn more of the =dplyr= package on
internet. The user community is large and you will find a lot of
question/answer in [[http://stackoverflow.com/questions/tagged/dplyr][stackoverflow]] from the =dplyr= package.

*** data.table
I started using =data.table= a couple of year ago. At first, this is very
hard and the syntax counterintuitive, but you will use to it.



