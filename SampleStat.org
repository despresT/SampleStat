#+AUTHOR: Tiphaine Després
#+email: tiphaine.despres@gmail.com
#+PROPERTY: BLOG Sample Stat
#+STARTUP: fninline overview

#+OPTIONS: <:nil d:nil timestamp:t
#+OPTIONS: ^:nil tags:nil
#+OPTIONS: toc:nil num:nil
#+SEQ_TODO: TODO READY DONE


* Emacs :Emacs:
** DONE Emacs + ESS = loving R :R:
   SCHEDULED: +<2016-12-30 ven.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2016-12-30-emacs-ess-loving-r
   :END:
   Since my second year of university I have studied Statistic with R on Windows using
   the basic text editor from the R GUI console. I was happy with it for a
   couple of years. However, when I start coding more complex and longer
   function, it was a nightmare to handle human issues, specially
   parentheses tracking. A professor told me that they were some programs
   specific to code in R, such as [[http://nbcgib.uesc.br/lec/software/editores/tinn-r/en][Tinn-R]] or the well known [[https://www.rstudio.com/][R-Studio]]. I
   also found that Notepad++ as a plugin ([[https://sourceforge.net/projects/npptor/][nppToR]]) to link the text
   editor to R. However, after trying R-Studio and Notepad++, I was not
   very happy with them. I always did not like the multi-windows
   design from R-Studio, and Notepad++ was only a better way to use
   the script function from the R GUI. It was not fully integrated
   R. Finally, my professor told me about Emacs, and how it was working
   with R. I first try it with Windows, using the very good
   [[http://vgoulet.act.ulaval.ca/en/emacs/][Emacs version from Vincent Goulet]]. It was exactly what I was looking for. A software
   that can interact with R without a lot of windows, and well integrated
   with R. Few years later, I jump to Linux using first Manjaro (an
   ArchLinux distribution), and after Xubuntu to keep the very good XFCE
   desktop environment.
   #+ATTR_HTML: :width 800
   [[/assets/images/screenshoot-emacs.png][file:/assets/images/screenshoot-emacs.png]]
   For the reader who don't know anything about [[https://www.gnu.org/software/emacs/][Emacs]] this is a free
   software from the GNU licence which can speak R using [[https://ess.r-project.org/][ESS]] package (for Emacs
   Speaks Statistic). But Emacs did not speak only statistic, this is an
   incredible tool that can speak multiple computers languages, read your
   email and much more. In fact, I am writing this blog article using
   Emacs through  [[http://orgmode.org/][Org-mode]]. Emacs is a cross-platform program which can
   be used with Windows or Mac Os, and also Linux.
   I will put more articles in this blog describing how I am using Emacs
   with R, and for blogging, and hopefully you will consider it to use
   for your own projects.

** DONE =.emacs= in org mode                                             :blog:
   SCHEDULED: <2017-04-26 mer.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-04-26--emacs-in-org-mode-emacs-
   :END:

Usually, when you are using Emacs, all your favourite shortcut and
others Emacs characteristic are in the =.emacs= file. However, to have a
better =.emacs= organisation, I suggest you to use the org-mode with
your =.emacs=. Like this, you can organise very easily your =.emacs= and
put categories 

To doing so you will needed to put in your =.emacs= file a simple link to
the org file with every Emacs customisation. Thus, the =.emacs= should
be like this:

   #+BEGIN_SRC emacs-lisp :exports code
(package-initialize)
(require 'org)
(org-babel-load-file
 (expand-file-name "emacs-init.org"
                   "~/."))
   #+END_SRC

And then you will have another file here name =emacs-init.org= which
should start like this for example:

#+BEGIN_SRC org 

'* Init
'** Packages & others
'#+BEGIN_SRC emacs-lisp
(require 'package)
(add-to-list 'package-archives
           '("melpa-stable" . "https://stable.melpa.org/packages/") t)
;(add-to-list 'package-archives
 ;            '("marmalade" . "http://marmalade-repo.org/packages/") t)
(add-to-list 'package-archives
	     '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(package-initialize)
'#+END_SRC

'** LaTeX
'#+BEGIN_SRC emacs-lisp
(load "auctex.el" nil t t)
;(load "preview-latex.el" nil t t)
(pdf-tools-install)

...
'#+END_SRC


#+END_SRC

As you can see, you simply need to put your =emacs-lisp= code using
the =#+BEGIN_SRC= and =#+END_SRC= tags.


** dd

* R :R:
** DONE For loop                                                       :Loop:
   SCHEDULED: <2017-01-20 ven.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-01-20-for-loop
   :END:
   Using loop with R is not the proper behaviour to have. Indeed,
   using the apply functions family such as /tapply/, /lapply/, and so
   one are a better way to do it, but for me, this is in some case too
   complicated.
   The apply family functions improve the speed rate of T and the management of the memory. Thus,  apply functions is relevant to use when you have big data-set to play with.
   Instead of using apply functions, I used =for= loop. This is simpler to understand it  for me and with moderate data-set (about few thousand of rows and 100 columns) the gain of apply functions is limited.
   Like this, =for= loop can be read again quickly even when you comeback to your code years later.
   I will now provide a small example to understand when you can use =for= loop and how to used them.  Also, note that understanding =for= loop will lead to use =foreach= function which allow parallelisation computing. It will be explain in another post.
   
   So, let's begin the =for= loop example.
   I will show you how to do spaghetti plot from tree ring data. 
*** About the data 
    Every year, tree make rings. We can count them to have the tree
    age, and also measure them to know a little more about the tree
    and its story. Indeed, tree increment (ring width from a year to
    another) give information on past climate, past disturbances
    (pest, drought, fire, ice and wind storms, etc.). 

    In this data set([[/assets/data/tree rings increment.txt][tree rings increment]]) you will find tree rings
    increment [in mm] from 19
    different trees (V1 to V19). The NA value is for year without
    increment information for this tree (it was not born), and the row
    #270 is for AD 2011  and the row #1 for AD 1741.
    
    The data look like this:
   #+NAME: data_ring
   #+BEGIN_SRC R :results output :exports both :session t 
setwd("./assets/data/") # change following your own working directory
library(data.table) #load data.table at least V.1.10 (to have fread function)
increment_data <- fread("tree rings increment.txt")

##if you did not want to use data.table V1.10 (which allow the fread function use the following code
#increment_data <- read.table("tree rings increment.txt",sep=";",h=T) #for your data,
#Because trees have not the same age, there is a lot of NA value and the length of
#your data frame is equal to the year of the oldest trees (for me it was a tree not show in this sub-sample).
#print(increment_data[1:3])

increment_data[, .(V1,V2,V3)]

#+END_SRC

#+RESULTS: data_ring
#+begin_example
data.table 1.10.0
  The fastest way to learn (by data.table authors): https://www.datacamp.com/courses/data-analysis-the-data-table-way
  Documentation: ?data.table, example(data.table) and browseVignettes("data.table")
  Release notes, videos and slides: http://r-datatable.com
         V1     V2    V3
  1:     NA     NA    NA
  2:     NA     NA    NA
  3:     NA     NA    NA
  4:     NA     NA    NA
  5:     NA     NA    NA
 ---                    
266: 128.99 182.54 66.89
267: 130.45 182.80 67.14
268: 131.54 183.24 67.50
269: 132.25 183.48 67.73
270: 132.76 184.34 68.14
#+end_example

We are now going to plot each tree starting from their first year of
growth record (i.e. the closest year to the row #1), and then continue
until the year AD 2011 (i.e. row #270). 
Because in data-set there is no year with 0 of increment, we need to
add it for each trees using the following code example for one tree: 

   #+BEGIN_SRC R :results output  :exports both :session t
    # the 3 following code line are just to help to generate the graphic frame
increment_data_unique <- increment_data[,1]
increment_data_unique <- increment_data_unique[complete.cases(increment_data_unique) ]
increment_data_unique <- rbind(list(0),increment_data_unique)
# I am pretty sure that those 3 lines of code are not required.
as.data.table(increment_data_unique)
   #+END_SRC 

   #+RESULTS:
   #+begin_example
	    V1
     1:   0.00
     2:   0.71
     3:   1.64
     4:   2.07
     5:   2.46
    ---       
   137: 128.99
   138: 130.45
   139: 131.54
   140: 132.25
   141: 132.76
#+end_example
Here we can see that we remove all NA value, and put a 0.00 value for
the first year of growth of the tree



Because we need to do it for each 19 trees, this is easier to do it
within a =for= loop like this:

   #+BEGIN_SRC R :results graphics :exports code :session t :file "Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg" :width 1200 :height 1000 :units "px"
#pdf("Multiplot radial growth sugar maple between 150 and 160 years old.pdf", width=12, height=8) #to save the plot as PDF

plot(as.numeric(rownames(increment_data_unique))-1,increment_data_unique[[1]],xlab="Age [in years]",
     ylab="radial growth [in mm]",main="Radial growth of 19 trees between 150 and 160 yrs",
     type="n",ylim=c(0,250),xlim=c(0,165)) #generate just the frame of the graphic to have all the same scale

for (i in names(increment_data)) { #for loop to draw one by one, each line of tree increments, starting all in age 0
 #use of names(increment_data) to have the names of each trees from "V1" to "V19"

    increment_data_unique <-increment_data[,i,with=F]#with=FALSE to have the whole column
    increment_data_unique <- as.data.frame(increment_data_unique[complete.cases(increment_data_unique), ]) #remove all the NA value
    increment_data_unique <- rbind(0,increment_data_unique) # add the 0 mm of DBH to start all tree at 0 years-old, 0 DBH
    par(new=TRUE) #allow to combine plots
    plot(as.numeric(rownames(increment_data_unique))-1,increment_data_unique[[1]],xlab="Age [in years]",
         ylab="radial growth [in mm]",
         main="Radial growth of 19 trees between 150 and 160 yrs",type="l",ylim=c(0,250),xlim=c(0,165)) #draw the plots for a single tree.
    #then restart the loop with the next tree, etc.
}
#dev.off() # save the graphic in your directory

   #+END_SRC

   #+RESULTS:
   [[file:Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg]]

  #+ATTR_HTML: :width 800
  [[/assets/data/Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg][file:/assets/data/Multiplot_radial_growth_sugar_maple_between_150_and_160_years_old.jpg]]


If you want, I have put the all code in my GitHub with the data-set [[https://github.com/despresT/Dendro-spaghetti-plot][Dendro-spaghetti-plot]]
 




** DONE Convert factor to character
   SCHEDULED: <2017-02-12> :factor:convert:
   SCHEDULED: <2017-01-12 jeu.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-01-12-convert-factor-to-character
   :END:
   In R, you used sometimes functions to convert vectors to another
   format with =as.character=, =as.factor= or =as.numeric=.
   However, you need to be careful when using the function =as.numeric= on
   a factor. Indeed, if the factor contains factor number, it will
   convert them to the level number and not convert the writing number
   from your factor.
   Here is a short example:
   #+NAME: block1
   #+BEGIN_SRC R :results output :exports both :session t
   library(data.table)
   set.seed(23) #set.seed to have the same random value as in this example
   to_convert <- factor(runif(1:10, min = 0, max = 100))
   print(levels(to_convert))
   #+END_SRC
   #+RESULTS: block1
   : data.table 1.9.8
   :   The fastest way to learn (by data.table authors): https://www.datacamp.com/courses/data-analysis-the-data-table-way
   :   Documentation: ?data.table, example(data.table) and browseVignettes("data.table")
   :   Release notes, videos and slides: http://r-datatable.com
   :  [1] "22.3072855733335" "33.1896589370444" "42.3720560967922" "57.6603659661487"
   :  [5] "71.072455169633"  "81.9448956055567" "84.052187949419"  "96.3544549420476"
   :  [9] "97.8130409261212" "99.6611237060279"
   #+BEGIN_SRC R :session t :results table :colnames yes :exports both
   data.table(factor_to_convert = to_convert,
   using_as_numeric_only = as.numeric(to_convert),
   using_as_character_first = as.numeric(as.character(to_convert)))
   #+END_SRC
   #+RESULTS:
   | factor_to_convert | using_as_numeric_only | using_as_character_first |
   |-------------------+-----------------------+--------------------------|
   |  57.6603659661487 |                     4 |         57.6603659661487 |
   |  22.3072855733335 |                     1 |         22.3072855733335 |
   |  33.1896589370444 |                     2 |         33.1896589370444 |
   |   71.072455169633 |                     5 |          71.072455169633 |
   |  81.9448956055567 |                     6 |         81.9448956055567 |
   |  42.3720560967922 |                     3 |         42.3720560967922 |
   |  96.3544549420476 |                     8 |         96.3544549420476 |
   |  97.8130409261212 |                     9 |         97.8130409261212 |
   |   84.052187949419 |                     7 |          84.052187949419 |
   |  99.6611237060279 |                    10 |         99.6611237060279 |
   So, be careful when you are using factor with numerical levels and you
   want to convert them.


** DONE Creating a function                                        :function:
   SCHEDULED: <2017-01-22 dim.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-01-22-creating-a-function
   :END:
   In R, most of people used build-in functions which are very useful
   for all basics statistical analyses. When you need to do more complex
   statistics you can use packages.
   There is almost every current statistical functions and more in the
   [[https://cran.r-project.org/][CRAN repository]]. However, time to time you will need to build your own function. Usually, when I build a function is because =for= loop will not be efficient and that I need to put different parameters that I can change.
   I will take here an easy example that I have previously done for my work.
   I wanted to build a short function to draw maps and save them if I needed to.

#+BEGIN_SRC R  :session t :exports none

setwd("./assets/data")

#+END_SRC

#+RESULTS:
: /home/tiphaine/blog/SampleStat
*** The data
There is two tables in this example. The first one
[[/assets/data/data_plot_scale.txt][data_plot_scale.txt]] is data of forest plots location, with different
information such as the trees status, the (living or dead), mark (NA
for no marks, DBH for trees with diameter information), dead for dead
trees position only and mortality for mortality pattern), the stands names (Stand_ID.m),
lng for longitude and lat for latitude coordinates and a result like
state 1 to 3 in the column pattern_state.
The second table is very similar but at the stand scale
[[/assets/data/data_stand_scale.txt][data_stand_scale.txt]].

Those data represent results of spatial patterns (aggregation,
repulsion or random) in forest at the plot and stand scales. Because
several plots, which could have different patterns states, are in one
stands, the stands patterns could be different from the plots
scale. Also, because I needed a tree threshold to compute spatial
patterns, there is few plots and stands that cannot be analyse for the
dead status (stands #4, for example).

#+BEGIN_SRC R :results output :exports both :session t 
library(data.table)
data_plot_pat <- fread("data_plot_scale.txt") #read the data
data_stand_pat <- fread("data_stand_scale.txt")

data_plot_pat
#+END_SRC

#+RESULTS:
#+begin_example
      Status mark Stand_ID.m      lng      lat pattern_state
   1:   dead dead         17 20.11335 49.18592        state2
   2:   dead dead         17 20.11335 49.18592        state2
   3:   dead dead         17 20.11335 49.18592        state2
   4:   dead dead         17 20.11794 49.18627        state2
   5:   dead dead         17 20.11798 49.18874        state2
  ---                                                       
1544: living   NA         33       NA       NA        state2
1545: living   NA         33       NA       NA        state2
1546: living   NA         33       NA       NA        state2
1547: living   NA         33       NA       NA        state1
1548: living   NA         33       NA       NA        state1
#+end_example

When doing functions you will need first to create arguments (vector) that will
be used in the function. 
In this example, I will use status as a proxy
for Status (note the S uppercase difference), markk for selecting
mark, and then just 2 others FALSE or TRUE vector is I want to have
the graphics outputs with the stands and if I want to save same or not
in the current directory.

*** The function 
#+BEGIN_SRC R :results output :exports code :session t
map_draw_blog <- function (status, markk, with.stand, save, ...) { #usually put ... to path others arguments
    library(ggmap)#use library instead of require to stop the function if you did not have the library
    library(ggplot2)
    library(data.table)
     #plot prep data
    setkey(data_plot_pat, Status, mark)
    #below you need to put %in% for the mark to take into account the mark == NA
    for_mapping_plot  <- data_plot_pat[Status == status & mark %in% markk] [, .( Stand_ID.m,lng, lat, pattern_state)] 

    #remove duplicated rows
    for_mapping_plot <- for_mapping_plot [!duplicated(for_mapping_plot )]

     #Stand prep data
    small_data_inf <- data_plot_pat[, .( Stand_ID.m, lng, lat)]

    #compute the mean of lng and lat by Stand_ID.m with removing NA value  only to remove lat and lng NA value
    to_map <-small_data_inf[, lapply(.SD, mean, na.rm = T), by = Stand_ID.m]

    pattern_to_put_map <- data_stand_pat[Status == status & mark %in% markk] [, .(Stand_ID.m, pattern_state)]

    for_mapping <- merge(to_map, pattern_to_put_map, by = "Stand_ID.m", all = T)#all = TRUE to keep all the no match from the 2 tables
    #keep only data with complete cases (remove row with NA values)
    for_mapping <- for_mapping[complete.cases(for_mapping)]
    
    #create the map background using Google satellite data
    google_map <- get_map(location = c(14,46,26,49),  maptype = "satellite", source = "google", zoom = 6)
    if(with.stand == TRUE) {
        if(save == TRUE) {
            ggmap(google_map) +  geom_point(data = for_mapping, aes(
        lng,  lat, color = factor(pattern_state)), 
	size = 10, alpha =.80)+  geom_point(data = for_mapping_plot,
        aes( lng,  lat, color = factor(pattern_state)), size = 2)+  
	geom_label(data = for_mapping, aes(lng,  lat + .2, label =
        Stand_ID.m,color = factor(pattern_state)), size = 4) + 
	ggsave(paste0(status, " ", markk, " map with stand and plots patterns.jpg"))
        } else { #end if save = TRUE
            ggmap(google_map) +  geom_point(data = for_mapping, aes(
        lng,  lat, color = factor(pattern_state)), 
	size = 10, alpha =.80)+  geom_point(data = for_mapping_plot,
        aes( lng,  lat, color = factor(pattern_state)), size = 2) +  
	geom_label(data = for_mapping, aes(lng,  lat + .2, label = Stand_ID.m,color = factor(pattern_state)), size = 4)
        }
    } else { #end if with.stand = TRUE
        if(save == TRUE) {
            ggmap(google_map) +  geom_point(data = for_mapping_plot,
        aes( lng,  lat, color = factor(pattern_state)), size = 2)+  
	geom_label(data = for_mapping_plot, aes(lng,  lat + .2, label
        = Stand_ID.m,color = factor(pattern_state)), size = 4) + 
	ggsave(paste0(status, " ", markk, " map without stand and plots patterns.jpg"))
        } else {
            ggmap(google_map) + geom_point(data = for_mapping_plot, aes( lng,  lat, color = factor(pattern_state)), size = 2)
        }
    }
}
#+END_SRC

#+RESULTS:

Here you can use the freshly build function =map_draw= that we just
created. The status can be ="living"= or ="dead"=. 
For the =markk= note that you need to put =NA= without any quote. Also,
you can put just F for FALSE or write FALSE, and the same for TRUE,
the result will be the same.

 #+BEGIN_SRC R :session t :exports code :results output graphics :width 1200 :height 1000 :units "px" :file "./assets/data/plot_stand.jpg"
map_draw_blog(status = "living", markk = NA, with.stand = T, save = F)
map_draw_blog(status = "living", markk = "DBH", with.stand = FALSE, save = T)
map_draw_blog(status = "dead", markk = "dead", with.stand = T, save = TRUE)
map_draw_blog(status = "dead", markk = "mortality", with.stand = T, save = T)
#+END_SRC

  #+ATTR_HTML: :width 800
[[/assets/data/fourplots.png][file:/assets/data/fourplots.png]]

I edit the graph using [[https://inkscape.org/en/][Inkscape]] to put a red arrow on the plots/stands
that appear only for living status.



** DONE Nested =for= loop                                                :loop:
   SCHEDULED: <2017-03-24 ven.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-03-24-nested-for-loop
   :END:
I already talk about single =for= loop in a [[http://samplestat.org/for-loop/][previous post]]. The same way
we did =for= loop for a single object, we can do it multiple times.

Here a short example:
#+BEGIN_SRC R  :session t :exports none

setwd("./assets/data")

#+END_SRC

#+RESULTS:


First import the data from [[/assets/data/data_stand_scale.txt][here]]
#+BEGIN_SRC R :results output :exports both :session t 
library(data.table) #load data.table at least V.1.10 (to have fread function)
data_stand <- fread("data_stand_scale.txt") #read the data

data_stand
#+END_SRC

#+RESULTS:
#+begin_example
data.table 1.10.4
  The fastest way to learn (by data.table authors): https://www.datacamp.com/courses/data-analysis-the-data-table-way
  Documentation: ?data.table, example(data.table) and browseVignettes("data.table")
  Release notes, videos and slides: http://r-datatable.com
     Status      mark Stand_ID.m pattern_state
  1: living        NA          1        state1
  2: living       DBH          1        state2
  3:   dead      dead          1        state1
  4:   dead mortality          1        state1
  5: living        NA          2        state3
 ---                                          
188: living       DBH         38        state2
189:   dead      dead         38        state1
190:   dead mortality         38        state3
191: living        NA         39        state1
192: living       DBH         39        state1
#+end_example



And then we can try a nested loop like this:
#+BEGIN_SRC R  :results outputs :exports both :session t :rownames yes :colnames yes
result_table <- NULL #create a NULL vector
for (i in unique(data_stand[, Status])) {
    new_data <- data_stand[Status == i]
    summary_all <- NULL #create a NULL vector which will be erase at each loop increment

    for (y in unique(new_data[, mark])) {
        summary <- dim(new_data[mark == y][pattern_state == "state1"])[1]
        summary_all <- cbind(summary_all, summary)
        rownames(summary_all) <- i #to have the rownames according to the Status level
    }
    result_table <- rbind(result_table, summary_all)
}
result_table
#+END_SRC

#+RESULTS:
|        | summary | summary |
|--------+---------+---------|
| living |       0 |       5 |
| dead   |      32 |      23 |

And here are the results. I know that we can do it in a simpler way,
it was just here as an example and before presenting you the =foreach=
loop which are used to do parallel computing.





** DONE data.table                                               :data_table:
   SCHEDULED: <2017-03-08 mer.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-03-08-data-table-data-table-
   :END:
When you are doing a lot of R, you can find two different kind of
people, the [[https://cran.r-project.org/web/packages/dplyr/index.html][dplyr]] and the [[https://github.com/Rdatatable/data.table/wiki][data.table]] people. Indeed, those to packages
are used for table manipulation. They are like the [[http://ggplot2.org/][ggplot2]] function
 for graphic, when you know them  they change
your R experience and you cannot go back. 

*** dplyr
I will not talk a lot about =dplyr= package, because I am not using
it. However, you need to know few things about it. Usually, =dplyr= is
used with another package named [[https://github.com/tidyverse/tidyr][tidyr]], and since recently, you
can find one package which will load both of them and more (load also
=ggplot2=, =readr=, etc.) and named [[https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/][tidyverse]].

To be simple, =dplyr= is very useful to handle object, and specially for
sorting, sub-sample, etc. thanks to the new operator =%>%=.
This operator will pipe object to another line to make more change on
it. It is very convenient to avoid typing multiple times the object
names like this:

#+BEGIN_SRC R :results outputs  :exports both
set.seed(121)
data <- rnorm(10)
data <- data + 44

# With dplyr package
library(dplyr)
set.seed(121)
data2 <- rnorm(10) %>%
    + 44

identical(data,data2)

#+END_SRC

#+RESULTS:
: TRUE

But, there is a lot of very nice function with =dplyr= to select,
sub.select, sort, replace data from tables.

If you are using emacs, you can define a key-bind for =%>%=. Here is the
lisp code you will need to put in your .emacs config file. 
#+BEGIN_SRC emacs-lisp
;;Define shortcut key for %>% function
(global-set-key (kbd "<M-f5>") 'dplyr-function)
(defun dplyr-function ()
  (interactive)
  (insert " %>%"))
#+END_SRC
Thus, in my example, the shortcut will be Meta (Alt) - f5. Of 
course, you can change it for whatever you like, just be sure that
your shortcut is not already use.

You will find a lot of site to learn more of the =dplyr= package on
internet. The user community is large and you will find a lot of
question/answer in [[http://stackoverflow.com/questions/tagged/dplyr][stackoverflow]] from the =dplyr= package.

*** data.table
I started using =data.table= a couple of years ago. At first, this is very
hard and the syntax is counter-intuitive, but you will use to it.
The =data.table= function is known to be faster than the =dplyr= package,
but the difference of speed will only be consequent for huge data set
(millions or rows and hundred of columns).

=data.table= use less verbose than =dplyr= but is more complex to write in
my opinion. Here is some examples ([[/assets/data/data_plot_scale.txt][the data are here]]):


#+BEGIN_SRC R  :session t :exports none

setwd("./assets/data")

#+END_SRC

#+RESULTS:


#+BEGIN_SRC R :results outputs  :exports both :session t
library(data.table)

data_plot_pat <- fread("data_plot_scale.txt") #read the data
data_plot_pat
dim(data_plot_pat)

#+END_SRC

#+RESULTS:
| 1548 |
|    6 |


#+BEGIN_SRC R :results outputs  :exports both :session t
setkey(data_plot_pat, Status, mark)#set in the data table "data_plot_pat" first the Status, and then the mark

selected_plot  <- data_plot_pat[Status == "living" & mark == "DBH"] [, .( Stand_ID.m,lng, lat, pattern_state)]#select plot with living status and DBH mark 
# and then subset only the Stand__ID_m name, lng, lat and pattern_state
print(dim(selected_plot))

#+END_SRC

#+RESULTS:
| 504 |
|   4 |


And you can add 
#+BEGIN_SRC R :results outputs  :exports both :session t
selected_plot[,  lat :=  lat + 100 ]#make some change on a existed vector. Here add 100 for each row on the "lat" vector

selected_plot[,  new_colmun :=  "repeated text"]#add a new column with the same value for each row (here this is "repeated text", but it could be numeric as well.
print(dim(selected_plot))

#+END_SRC

#+RESULTS:
| 504 |
|   5 |

As you can see, here there is a new column.


And if you are using emacs and R, I suggest you to add the following package in
your =.emacs= for the function =:== to have space between it, you can add
this code:

#+BEGIN_SRC emacs-lisp
;; Electric operator will turn a=10*5+2 into a = 10 * 5 + 2, so let’s enable it for R
(use-package electric-operator
  :ensure t
  :config
  (setq electric-operator-R-named-argument-style 'spaced)
  (add-hook 'ess-mode-hook #'electric-operator-mode))
(electric-operator-add-rules-for-mode 'ess-mode
  (cons ":=" " := "))
#+END_SRC

Also, the electric-operator will make you code easier to read by
adding space between operator such as " == ", or " + ", etc.


Because I am used to =data.table= and specially love the =fread= and
=fwrite= function to read and save tables, I did not want to use
=dplyr=. However, if you are a beginner, or you want to read old code
easily years later, I suggest you to use =dplyr=.


** DONE Workflow                                                   :workflow:
   SCHEDULED: <2017-02-14 mar.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-02-14-workflow
   :END:
How you organise yourself when doing R will make it easier for you if
you need to go back to your script weeks or years after, and to share
with others people.

There is different workflow that you can do. At first, when I was
working on a project, I was using a simple folder named =analyses= and
put everything in it with obscure name such as =spatial analyses.R= or
=canopy area analyses.R=, etc. I was also putting all the outputs
(Figures, tables, maps) in the same working directory as the .R scripts.

I think, this make it harder to find again some figures that you did
made.

Now I am using since a couple of year another workflow. I first used
number before each names to know which script I need to run at first
like =1 data upload.R=, =2 function point pattern.R= and =3 final
results.R=.

For the outputs, I have =.RData= saving files in the working directory,
but all my Figures are in different folder. Thus, for example, I have
a path like this =./living/NA/normal/replicate/Lmm graph/= with every
figures of the L_mm functions (a spatial pattern function) for the
replicate normal NA (no marks) and living patterns. 

I have a little script that help in R for checking if the path is here
and make a new folder or not if it already exist.

Here is the little script will check for the path =/Project X/Analyses/results RandomForest=:

#+BEGIN_SRC R :exports code
mainDir <- "/Project X/Analyses"#path do the main folder without "/" to the end
  

if (file.exists(file.path(mainDir, "results RandomForest"))) {
                        setwd(file.path(mainDir, "results RandomForest"))
                    } else {
                        dir.create(file.path(mainDir, "results RandomForest"), showWarnings = FALSE,recursive=TRUE)
                        setwd(file.path(mainDir, "results RandomForest"))
                    }
#+END_SRC


You can even add it in a =for= loop like this:

#+BEGIN_SRC R :exports code
mainDir <- "/Project X/Analyses"#path do the main folder without "/" to the end
#you can use here 
# mainDir <- getwd() # to have this script work
setwd(mainDir) 
variables_names <- c("temperature","slope","patterns")
for (i in variables_names) {
    library(ggplot2)
    library(ggthemes)

    if (file.exists(file.path(mainDir, "results RandomForest",i))) {
        setwd(file.path(mainDir, "results RandomForest",i))
    } else {
        dir.create(file.path(mainDir, "results RandomForest",i), showWarnings = FALSE,recursive=TRUE)
        setwd(file.path(mainDir, "results RandomForest",i))
    }
    ## making a empty graph and save it
    ggplot() +
        geom_text() +
        annotate("text", label = paste0("text with variables names  ",i ), x = 2, y = 15, size = 8, fontface = "bold") +
        theme_few() +
        ggsave(paste0("variables", "_", i,".pdf"))

    setwd(mainDir) #here very important to set the mainDir working directory again
}

#+END_SRC

Here it will check for three different paths in the same subfolder
=results RandomForest=

=/Project X/Analyses/results RandomForest/temperature=

=/Project X/Analyses/results RandomForest/slope=

=/Project X/Analyses/results RandomForest/patterns=

and save in each folder a file names =varialbes_temperature.pdf= (or slope.pdf
or patterns.pdf) in the folder temperature (or slope or patterns).

The outputs figures should look like this:
  #+ATTR_HTML: :width 800
[[/assets/data/variables_temperature.jpg][file:/assets/data/variables_temperature.jpg]]


** DONE parallelisation computing                   :foreach:parallelisation:
   SCHEDULED: <2017-05-10 mer.>
   :PROPERTIES:
   :EXPORT_JEKYLL_LAYOUT:
   :filename: 2017-05-10-parallelisation-computing
   :END:
   I already show you how to do =for= loop and nested =for= loop. When you
   want to do parallelisation computing, you simply replace the =for=
   command by the =foreach= command and =%dopart%=.

   Depending if you are on Windows, MacOS or Linux, you will need to
   do the parallelisation differently. I personally do it on Windows
   and Linux. 

   Within a =foreach= loop, you will need to declare the loop variable
   as you usually do in the =for= command, but also to declare the
   package that you are going to use within the foreach loop using the
   command =.packages=. You also need to set the =.multicombine= to TRUE
   is you want combine all the parallelism computing within a single
   output and finally you can use the =.final= argument to customise the
   output (list of list, etc.).

   Keep in mind that the parallelisation will be processing using the
   number of core that you declare in the =foreach= session and those
   results will be sort in the same 
#+BEGIN_SRC R  :session ppp :exports none

setwd("./assets/data")

#+END_SRC

#+RESULTS:
: /home/tiphaine/blog/SampleStat


   First we create 100 random point patterns with 2
   different marks "A" and "B" : 
#+BEGIN_SRC R :exports code  :session ppp
#creating random spatial data with 2 marks
library(spatstat)

plot_NA_list <- NULL
for (i in 1:100) {
    # some arbitrary coordinates in [0,1]
    x <- runif(70)
    y <- runif(70)

    # marks
    m <- as.factor(sample(c("A","B"), 70, replace=TRUE))
    #creat ppp with marks    
    X <- ppp(x, y, c(0,1), c(0,1), marks=m)
    X <- list(X)
    names(X) <- i #set the names for each ppp
    plot_NA_list <- append(plot_NA_list,X)#add the ppp to the list
}

plot_NA_list[1:2]

#+END_SRC

#+RESULTS:
|    0.593286141520366 |   0.604256486753002 | B |   0.102693731198087 |   0.358715818496421 | B |
|    0.201185174752027 |   0.985524686053395 | B |   0.740628755884245 |   0.479669122025371 | B |
|    0.288043662207201 |   0.776005536317825 | B |   0.500746790552512 |   0.836841818410903 | A |
|     0.96513672079891 |   0.524753422942013 | B |   0.274354553082958 |   0.967760905390605 | B |
|    0.212165845558047 |   0.875933838542551 | B |    0.28757659601979 |   0.625466128112748 | B |
|     0.91941485973075 |   0.436877099564299 | A |   0.428928926121444 |   0.890401996206492 | A |
|    0.203136377269402 |  0.0560893805231899 | B |   0.422618921147659 |   0.965077186003327 | B |
|    0.138674942310899 | 0.00984026421792805 | A |   0.655963290482759 |    0.67042997572571 | A |
|    0.170748900622129 |  0.0294745317660272 | A |   0.814554768614471 |   0.387496467446908 | B |
|    0.501614184118807 |   0.841812073485926 | B |   0.403940950753167 |   0.821532374015078 | A |
|    0.914616741705686 |   0.149258656660095 | A |   0.414204919477925 |   0.105881571536884 | A |
|    0.102353391703218 |   0.821948498487473 | B |  0.0206895186565816 |  0.0273088626563549 | A |
|    0.126074036117643 |   0.102304353378713 | A |   0.737746492261067 |   0.726260960102081 | A |
|   0.0449081035330892 |   0.511272851377726 | A |    0.86553224362433 |    0.13395572733134 | A |
|   0.0637196360621601 |   0.558615692425519 | A |   0.247510037152097 |   0.125631585018709 | B |
|    0.670557069359347 |   0.266577524598688 | A |   0.668472889810801 |   0.974375638645142 | B |
|    0.591924850828946 |   0.491091210162267 | A |   0.142526824725792 |   0.688221237622201 | B |
|    0.372858140151948 |   0.526669262442738 | A |   0.186734719201922 |  0.0696816279087216 | A |
|    0.658986933063716 |   0.960418550064787 | A |   0.537485116627067 |   0.340398359578103 | B |
|    0.310576266609132 |   0.859974181512371 | B |   0.308426023693755 |   0.819492156850174 | B |
|   0.0734357703477144 |   0.327121352776885 | B |   0.652999975951388 |   0.730109830852598 | B |
|    0.333805537782609 |   0.312755096936598 | A |    0.99480317113921 |   0.450378090841696 | B |
|    0.851656019454822 |   0.668196984566748 | A |   0.270941044669598 |   0.434838763438165 | B |
|    0.733847827417776 |   0.334057160187513 | B |   0.571843832964078 |   0.039171329466626 | B |
| 9.13576222956181e-05 |   0.702422443544492 | A |   0.890553813893348 |  0.0231619025580585 | A |
|    0.471319386735559 |   0.572190299164504 | A |   0.992072357330471 |   0.872539040632546 | B |
|     0.98379063187167 |   0.661888318369165 | A |   0.803318849997595 |   0.653235625009984 | B |
|     0.37080990197137 | 0.00606469600461423 | A |   0.102338598808274 |   0.533806695137173 | A |
|    0.159349340945482 |   0.716494684573263 | A |   0.176880112616345 |    0.82783253560774 | A |
|    0.173307834425941 |   0.409263501875103 | A |   0.262447523185983 |   0.855381201952696 | A |
|    0.760623181471601 |   0.686320679495111 | A |  0.0087492389138788 |    0.52924544760026 | B |
|    0.637862942181528 |   0.446116135455668 | A |   0.411632834235206 |   0.390228444943205 | B |
|   0.0472175877075642 |   0.282597193494439 | A |   0.177251051180065 |   0.705408114939928 | B |
|    0.835074779111892 |   0.395600761985406 | A |   0.564858476398513 |   0.377819805871695 | B |
|    0.642099376767874 |   0.372177217388526 | A |   0.841799673857167 |   0.558791830902919 | A |
|    0.580962139414623 |   0.513972240267321 | A |   0.507206979906186 |   0.432589015224949 | A |
|    0.987751088105142 |   0.433210629969835 | A |   0.345983834238723 |   0.699164659483358 | B |
|     0.57461340748705 |   0.423533261287957 | A |  0.0816105066332966 |   0.502191155217588 | B |
|    0.160996805410832 |   0.205099368467927 | B |   0.465847649844363 |   0.597105676541105 | B |
|    0.853318764129654 |   0.325124790659174 | B | 0.00159483356401324 |   0.504355677170679 | A |
|    0.602597740013152 |   0.318658720003441 | A |   0.462409271160141 |   0.609254021663219 | B |
|    0.336096978513524 |   0.172684325138107 | A |   0.596592411166057 | 0.00670313835144043 | B |
|     0.92900656349957 |   0.288645906373858 | A |   0.821298269787803 |   0.572509123012424 | A |
|    0.988951390143484 |  0.0691529689356685 | A |   0.996275168610737 |  0.0866821154486388 | B |
|    0.525532026775181 |   0.123462802963331 | A |   0.141928445547819 |   0.853865697514266 | A |
|    0.145615274552256 |   0.812563829822466 | A |   0.367377228336409 |   0.891399680171162 | A |
|    0.108302942709997 |    0.67596198967658 | B |   0.843584440415725 |   0.731495790882036 | A |
|    0.356994025642052 |   0.294353851350024 | A |   0.637877334142104 |   0.682387395529076 | B |
|   0.0112641174346209 |    0.20603835536167 | A |   0.207331195939332 |   0.937302223639563 | A |
|    0.748851914424449 |   0.130057137459517 | A |   0.965912809129804 |   0.571701853303239 | A |
|    0.383807615144178 |   0.581755623454228 | B |   0.363601377466694 |   0.664395462023094 | A |
|    0.822497961111367 |   0.920944334473461 | A |  0.0146735694725066 |   0.281129853334278 | B |
|    0.921194742200896 |   0.553964016959071 | B |   0.604896451113746 |  0.0382080525159836 | A |
|    0.267072118353099 |    0.52912595262751 | B |   0.328237150097266 |   0.695594228571281 | A |
|    0.851197695825249 |   0.493450877256691 | B |   0.301207363139838 |   0.753543081926182 | A |
|    0.398868947522715 |    0.82708052219823 | B |   0.149244443280622 |   0.249571278458461 | B |
|     0.16107241413556 |   0.567937285872176 | A |   0.521506405202672 |   0.997336214408278 | A |
|    0.212566475616768 |   0.444930252153426 | A |   0.628675166750327 |   0.991834060288966 | A |
|     0.27588234632276 |   0.622756352415308 | B |    0.83459775079973 |   0.421120259445161 | B |
|    0.585258349543437 |   0.656155701493844 | B |   0.699496850371361 |   0.775602252222598 | A |
|    0.240132712991908 |  0.0472344032023102 | A |   0.152763144811615 |   0.776388093363494 | B |
|    0.202905472833663 |   0.449018101906404 | A |   0.811260828049853 |   0.349188541062176 | B |
|    0.865190700162202 |   0.517248841468245 | A |  0.0920624821446836 |   0.147731502307579 | B |
|    0.949137168703601 |   0.532381859840825 | B |   0.337627252098173 |   0.677190314047039 | B |
|    0.298372923396528 |   0.531807000748813 | B |   0.494713584659621 |  0.0547771244309843 | A |
|    0.562916622729972 |    0.93622668273747 | B |   0.666923648212105 |   0.414440020918846 | A |
|    0.124352040700614 |   0.415849450509995 | B |   0.819462397834286 |   0.348857885226607 | A |
|    0.420224908506498 |   0.678710765205324 | A |   0.549888727022335 |   0.622323920018971 | B |
|    0.112907390343025 |   0.911894684424624 | B |   0.252718133153394 |   0.591033660806715 | A |
|    0.934902839595452 |   0.710496859857813 | A |   0.832258679438382 |   0.580885898089036 | B |

#+BEGIN_EXAMPLE
$`1`
Marked planar point pattern: 70 points
Multitype, with levels = A, B 
window: rectangle = [0, 1] x [0, 1] units

$`2`
Marked planar point pattern: 70 points
Multitype, with levels = A, B 
window: rectangle = [0, 1] x [0, 1] units
#+END_EXAMPLE

Before going more further, you will need to install the following
package in R: 
doMC (or doSNOW if you use Windows), spptest and marksummary package
which are 2 greats packages when you do spatial point pattern (you can
found them at [[https://github.com/myllym/GET][https://github.com/myllym/GET]] for the spptest package
and at [[https://github.com/myllym/marksummary][https://github.com/myllym/marksummary]] for the mark summary
package).

The following code will compute the "Lest" function overall 30
spatial pattern simulation (usually this is 2499 simulation) from the random data set. The "Lest" function will
basically see if the mark "A" from the spatial pattern is randomly
distributed regarding the mark "B" across the spatial pattern (this is
define in the =simulate= argument in the =envelope= function. Then, we
compute a rank envelope test ([[https://arxiv.org/abs/1307.0239v4][see here for more details]]). Thus, if the
result from the rank envelope test is significant and when we plot it
the observed data are above the envelope, then "A" and "B" have a
positive correlation relationship (i.e. there are attracted one to another), if this is below the envelope threshold,
then "A" and "B" have a negative correlation relationship (i.e. there
are segregate one to another).

Finally, we put the result of the rank envelope test into a list with
also the random labelling residual data.


#+BEGIN_SRC R :session ppp :exports code
library(doMC) #only for Linux,used library(doSNOW) for Windows and uncomment the above lines
#      clusterN <-  detectCores()-1  ### choose number of nodes to add to cluster in doSNOW ; Compute the number of core available from the computer less 1
#      cl = makeCluster(clusterN, rscript="Rscript.exe", type='SOCK')  ###Cluster for doSNOW
core <- detectCores()-1#Compute the number of core available from the computer less 1
registerDoMC(core)#registerDoSNOW(cl) ###for Windows

master_list <- NULL
z <- NULL

NA_list_result <- foreach(z = names(plot_NA_list),.packages = c("spatstat","spptest","marksummary"),.multicombine = TRUE, .final = function(z) setNames(z, names(plot_NA_list))) %dopar% {
    plot_NA_list <- plot_NA_list[[z]]

    ppp_envelope_NA <- envelope(plot_NA_list, fun = "Lest",nsim = 30,correction="translate",savefuns = TRUE,simulate = expression(runifpoint( plot_NA_list$n, win= plot_NA_list$window))) #need to change the simulation to 2499 and to add at the end 'simulate=expression(runifpoint(plot_one_specie$n, win=plot_one_specie$window))'
    ppp_curve_set_NA <- envelope_to_curve_set(ppp_envelope_NA) #change the envelope class in a curve_set class. Need to add the use_theo argument
    ppp_curve_set_NA$theo <-  ppp_curve_set_NA$r
    res_NA <- residual(ppp_curve_set_NA,use_theo = TRUE)
    rank_NA <- rank_envelope(res_NA,lexo = FALSE,savedevs = TRUE) #use to plot and to have result

    master_list <- list(rank_env_NA = rank_NA,random_labelling = res_NA) #,residual_NA=res_NA
    return(master_list)
}  #stopCluster(cl)
###End of parallelisation for Windows and Linux

#+END_SRC

#+RESULTS:

It will took some time to compute every 100 spatial patterns.

Then you should have this list of result:

#+BEGIN_SRC R :session ppp  :results outup :exports both
NA_list_result[1:2]

#+END_SRC

#+RESULTS:

#+begin_example
$`1`
$`1`$rank_env_NA
Rank envelope test
 p-value of the test: 0.3225806 (ties method: midrank)
 p-interval         : (0.03225806, 0.6129032)

$`1`$random_labelling
curve_set object containing :
List of 4
 $ r          : num [1:513] 0 0.000488 0.000977 0.001465 0.001953 ...
 $ obs        : num [1:513] 0 -0.000488 -0.000977 -0.001465 -0.001953 ...
 $ sim_m      : num [1:513, 1:30] 0 -0.000488 -0.000977 -0.001465 -0.001953 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:513] "1" "2" "3" "4" ...
  .. ..$ : chr [1:30] "sim1" "sim2" "sim3" "sim4" ...
 $ is_residual: logi TRUE
 - attr(*, "class")= chr "curve_set"


$`2`
$`2`$rank_env_NA
Rank envelope test
 p-value of the test: 0.8709677 (ties method: midrank)
 p-interval         : (0.8064516, 0.9354839)

$`2`$random_labelling
curve_set object containing :
List of 4
 $ r          : num [1:513] 0 0.000488 0.000977 0.001465 0.001953 ...
 $ obs        : num [1:513] 0 -0.000488 -0.000977 -0.001465 -0.001953 ...
 $ sim_m      : num [1:513, 1:30] 0 -0.000488 -0.000977 -0.001465 -0.001953 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:513] "1" "2" "3" "4" ...
  .. ..$ : chr [1:30] "sim1" "sim2" "sim3" "sim4" ...
 $ is_residual: logi TRUE
 - attr(*, "class")= chr "curve_set"
#+end_example


You can now plot the results from the rank envelope test:

#+BEGIN_SRC R :session ppp :results output :exports code 
library(ggplot2)
jpeg("rank_envelope.jpg",width = 1200, height = 1200, units = "px",quality = 100)
plot(NA_list_result$"1"$rank_env_NA,use_ggplot2=TRUE)
dev.off()
#+END_SRC

#+RESULTS:
: Warning message:
: `legend.margin` must be specified using `margin()`. For the old behavior use legend.spacing
: null device 
:           1

  #+ATTR_HTML: :width 800
[[/assets/data/rank_envelope.jpg][file:/assets/data/rank_envelope.jpg]]


  

* Blog                                                                 :Blog:
** TODO Blogging with Emacs in org-mode                           :org:Emacs:
   As I already told you in my first blog-post, I use to blog here with
   only Emacs using the org-mode. There is different way to use Emacs and
   org-mode for blogging, I used the [[https://github.com/Malabarba/ox-jekyll-subtree][ox-jekyll-subtree]] from [[http://endlessparentheses.com/][Malabarba]] which allow
   you to have all your blog posts within one =.org= file. This is very
   convenient to find older blog post and a clearer blog folder. Also,
   you can have your blog in your =.emacs= file if you want
